import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as pimg
from matplotlib.patches import Rectangle
import struct
import cv2

def IntervalOverlap(A, B):
	# Finds Intersection Dimension
    x1, x2 = A
    x3, x4 = B

    if x3 < x1:
        if x4 < x1:
            return 0
        else:
            return min(x2,x4) - x1
    else:
        if x2 < x3:
             return 0
        else:
            return min(x2,x4) - x3
   
def Sigmoid(x):
	# Computes Sigmoid Function
    return 1. / (1. + np.exp(-x))


def IOU(box1, box2):
	# Intersection over Union
    W_intersection = IntervalOverlap([box1.xmin, box1.xmax], [box2.xmin, box2.xmax])
    H_intersection = IntervalOverlap([box1.ymin, box1.ymax], [box2.ymin, box2.ymax])
    
    IntersectionArea = W_intersection * H_intersection

    w1, h1 = box1.xmax-box1.xmin, box1.ymax-box1.ymin
    w2, h2 = box2.xmax-box2.xmin, box2.ymax-box2.ymin
    
    UnionArea = w1*h1 + w2*h2 - IntersectionArea
    
    return float(IntersectionArea) / UnionArea

def PreprocessInput(image, net_h, net_w):
    new_h, new_w, _ = image.shape

    # determine the new size of the image
    if (float(net_w)/new_w) < (float(net_h)/new_h):
        new_h = (new_h * net_w)/new_w
        new_w = net_w
    else:
        new_w = (new_w * net_h)/new_h
        new_h = net_h

    # resize the image to the new size
    resized = cv2.resize(image[:,:,::-1]/255., (int(new_w), int(new_h)))

    # embed the image into the standard letter box
    new_image = np.ones((net_h, net_w, 3)) * 0.5
    new_image[int((net_h-new_h)//2):int((net_h+new_h)//2), int((net_w-new_w)//2):int((net_w+new_w)//2), :] = resized
    new_image = np.expand_dims(new_image, 0)

    return new_image


def DecodeNetworkOutput(netout, anchors, obj_thresh, NMS_Threshold, net_h, net_w):
    grid_h, grid_w = netout.shape[:2]
    nb_box = 3
    netout = netout.reshape((grid_h, grid_w, nb_box, -1))
    nb_class = netout.shape[-1] - 5

    boxes = []

    netout[..., :2]  = Sigmoid(netout[..., :2])
    netout[..., 4:]  = Sigmoid(netout[..., 4:])
    netout[..., 5:]  = netout[..., 4][..., np.newaxis] * netout[..., 5:]
    netout[..., 5:] *= netout[..., 5:] > obj_thresh

    for i in range(grid_h*grid_w):
        row = i / grid_w
        col = i % grid_w
        
        for b in range(nb_box):
            # 4th element is objectness score
            objectness = netout[int(row)][int(col)][b][4]
            #objectness = netout[..., :4]
            
            if(objectness.all() <= obj_thresh): continue
            
            # first 4 elements are x, y, w, and h
            x, y, w, h = netout[int(row)][int(col)][b][:4]

            x = (col + x) / grid_w # center position, unit: image width
            y = (row + y) / grid_h # center position, unit: image height
            w = anchors[2 * b + 0] * np.exp(w) / net_w # unit: image width
            h = anchors[2 * b + 1] * np.exp(h) / net_h # unit: image height  
            
            # last elements are class probabilities
            classes = netout[int(row)][col][b][5:]
            
            box = BoundBox(x-w/2, y-h/2, x+w/2, y+h/2, objectness, classes)
            #box = BoundBox(x-w/2, y-h/2, x+w/2, y+h/2, None, classes)

            boxes.append(box)

    return boxes

def CorrectBoxes(boxes, image_h, image_w, net_h, net_w):
	# Reseting Dimensions for all Boxes
	# Correction from Original Code
    if (float(net_w)/image_w) < (float(net_h)/image_h):
        new_w = net_w
        new_h = (image_h*net_w)/image_w
    else:
        new_h = net_w
        new_w = (image_w*net_h)/image_h
        
    for i in range(len(boxes)):
        x_offset, x_scale = (net_w - new_w)/2./net_w, float(new_w)/net_w
        y_offset, y_scale = (net_h - new_h)/2./net_h, float(new_h)/net_h
        
        boxes[i].xmin = int((boxes[i].xmin - x_offset) / x_scale * image_w)
        boxes[i].xmax = int((boxes[i].xmax - x_offset) / x_scale * image_w)
        boxes[i].ymin = int((boxes[i].ymin - y_offset) / y_scale * image_h)
        boxes[i].ymax = int((boxes[i].ymax - y_offset) / y_scale * image_h)
        
def NonMaxSupression(boxes, NMS_Threshold):
    if len(boxes) > 0:
        nb_class = len(boxes[0].classes)
    else:
        return
        
    for c in range(nb_class):
        sorted_indices = np.argsort([-box.classes[c] for box in boxes])

        for i in range(len(sorted_indices)):
            index_i = sorted_indices[i]

            if boxes[index_i].classes[c] == 0: continue

            for j in range(i+1, len(sorted_indices)):
                index_j = sorted_indices[j]

                if IOU(boxes[index_i], boxes[index_j]) >= NMS_Threshold:
                    boxes[index_j].classes[c] = 0

class BoundBox:
    def __init__(self, xmin, ymin, xmax, ymax, objness = None, classes = None):
        self.xmin = xmin
        self.ymin = ymin
        self.xmax = xmax
        self.ymax = ymax
        
        self.objness = objness
        self.classes = classes

        self.label = -1
        self.score = -1

    def getLabel(self):
        if self.label == -1:
            self.label = np.argmax(self.classes)
        return self.label
    
    def getScore(self):
        if self.score == -1:
            self.score = self.classes[self.getLabel()]
        return self.score

def Draw_Boxes(ImagePath, v_boxes, v_labels, v_scores):
	# Plotting Results
    img = pimg.imread(ImagePath)
    fig,ax = plt.subplots(1)
    for i in range(len(v_boxes)):
        box = v_boxes[i]
        y1, x1, y2, x2 = max(box.ymin,0), max(box.xmin,0), max(box.ymax,0), max(box.xmax,0)
        width, height = x2 - x1, y2 - y1

        rect = Rectangle((x1, y1), width, height, fill=False, color='red', angle=0)
        label = "%s (%.3f)" % (v_labels[i], v_scores[i])
        ax.add_patch(rect)
        ax.text(x1,y1,label,color='red')

    ax.imshow(img)
    plt.show()

def getBoxes(boxes, labels, thresh):
	v_boxes, v_labels, v_scores = list(), list(), list()
	# enumerate all boxes
	for box in boxes:
		# enumerate all possible labels
		for i in range(len(labels)):
			# check if the threshold for this label is high enough
			if box.classes[i] > thresh:
				v_boxes.append(box)
				v_labels.append(labels[i])
				v_scores.append(box.classes[i]*100)
				# don't break, many labels may trigger for one box
	return v_boxes, v_labels, v_scores
